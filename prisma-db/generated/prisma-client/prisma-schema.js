module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.27.4). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAppointment {
  count: Int!
}

type AggregateClientMessage {
  count: Int!
}

type AggregateDoctor {
  count: Int!
}

type AggregateServiceMessage {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Appointment {
  id: ID!
  service: Doctor!
  client: User
  clientName: String
  title: String
  startTime: String!
  endTime: String!
  duration: AppointmentDuration!
  local: Boolean!
}

type AppointmentConnection {
  pageInfo: PageInfo!
  edges: [AppointmentEdge]!
  aggregate: AggregateAppointment!
}

input AppointmentCreateInput {
  service: DoctorCreateOneWithoutAppointmentsInput!
  client: UserCreateOneWithoutAppointmentsInput
  clientName: String
  title: String
  startTime: String!
  endTime: String!
  duration: AppointmentDuration!
  local: Boolean!
}

input AppointmentCreateManyWithoutClientInput {
  create: [AppointmentCreateWithoutClientInput!]
  connect: [AppointmentWhereUniqueInput!]
}

input AppointmentCreateManyWithoutServiceInput {
  create: [AppointmentCreateWithoutServiceInput!]
  connect: [AppointmentWhereUniqueInput!]
}

input AppointmentCreateWithoutClientInput {
  service: DoctorCreateOneWithoutAppointmentsInput!
  clientName: String
  title: String
  startTime: String!
  endTime: String!
  duration: AppointmentDuration!
  local: Boolean!
}

input AppointmentCreateWithoutServiceInput {
  client: UserCreateOneWithoutAppointmentsInput
  clientName: String
  title: String
  startTime: String!
  endTime: String!
  duration: AppointmentDuration!
  local: Boolean!
}

enum AppointmentDuration {
  VERY_SHORT
  SHORT
  LONG
  VERY_LONG
}

type AppointmentEdge {
  node: Appointment!
  cursor: String!
}

enum AppointmentOrderByInput {
  id_ASC
  id_DESC
  clientName_ASC
  clientName_DESC
  title_ASC
  title_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
  duration_ASC
  duration_DESC
  local_ASC
  local_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AppointmentPreviousValues {
  id: ID!
  clientName: String
  title: String
  startTime: String!
  endTime: String!
  duration: AppointmentDuration!
  local: Boolean!
}

input AppointmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  clientName: String
  clientName_not: String
  clientName_in: [String!]
  clientName_not_in: [String!]
  clientName_lt: String
  clientName_lte: String
  clientName_gt: String
  clientName_gte: String
  clientName_contains: String
  clientName_not_contains: String
  clientName_starts_with: String
  clientName_not_starts_with: String
  clientName_ends_with: String
  clientName_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  duration: AppointmentDuration
  duration_not: AppointmentDuration
  duration_in: [AppointmentDuration!]
  duration_not_in: [AppointmentDuration!]
  local: Boolean
  local_not: Boolean
  AND: [AppointmentScalarWhereInput!]
  OR: [AppointmentScalarWhereInput!]
  NOT: [AppointmentScalarWhereInput!]
}

type AppointmentSubscriptionPayload {
  mutation: MutationType!
  node: Appointment
  updatedFields: [String!]
  previousValues: AppointmentPreviousValues
}

input AppointmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AppointmentWhereInput
  AND: [AppointmentSubscriptionWhereInput!]
  OR: [AppointmentSubscriptionWhereInput!]
  NOT: [AppointmentSubscriptionWhereInput!]
}

input AppointmentUpdateInput {
  service: DoctorUpdateOneRequiredWithoutAppointmentsInput
  client: UserUpdateOneWithoutAppointmentsInput
  clientName: String
  title: String
  startTime: String
  endTime: String
  duration: AppointmentDuration
  local: Boolean
}

input AppointmentUpdateManyDataInput {
  clientName: String
  title: String
  startTime: String
  endTime: String
  duration: AppointmentDuration
  local: Boolean
}

input AppointmentUpdateManyMutationInput {
  clientName: String
  title: String
  startTime: String
  endTime: String
  duration: AppointmentDuration
  local: Boolean
}

input AppointmentUpdateManyWithoutClientInput {
  create: [AppointmentCreateWithoutClientInput!]
  delete: [AppointmentWhereUniqueInput!]
  connect: [AppointmentWhereUniqueInput!]
  set: [AppointmentWhereUniqueInput!]
  disconnect: [AppointmentWhereUniqueInput!]
  update: [AppointmentUpdateWithWhereUniqueWithoutClientInput!]
  upsert: [AppointmentUpsertWithWhereUniqueWithoutClientInput!]
  deleteMany: [AppointmentScalarWhereInput!]
  updateMany: [AppointmentUpdateManyWithWhereNestedInput!]
}

input AppointmentUpdateManyWithoutServiceInput {
  create: [AppointmentCreateWithoutServiceInput!]
  delete: [AppointmentWhereUniqueInput!]
  connect: [AppointmentWhereUniqueInput!]
  set: [AppointmentWhereUniqueInput!]
  disconnect: [AppointmentWhereUniqueInput!]
  update: [AppointmentUpdateWithWhereUniqueWithoutServiceInput!]
  upsert: [AppointmentUpsertWithWhereUniqueWithoutServiceInput!]
  deleteMany: [AppointmentScalarWhereInput!]
  updateMany: [AppointmentUpdateManyWithWhereNestedInput!]
}

input AppointmentUpdateManyWithWhereNestedInput {
  where: AppointmentScalarWhereInput!
  data: AppointmentUpdateManyDataInput!
}

input AppointmentUpdateWithoutClientDataInput {
  service: DoctorUpdateOneRequiredWithoutAppointmentsInput
  clientName: String
  title: String
  startTime: String
  endTime: String
  duration: AppointmentDuration
  local: Boolean
}

input AppointmentUpdateWithoutServiceDataInput {
  client: UserUpdateOneWithoutAppointmentsInput
  clientName: String
  title: String
  startTime: String
  endTime: String
  duration: AppointmentDuration
  local: Boolean
}

input AppointmentUpdateWithWhereUniqueWithoutClientInput {
  where: AppointmentWhereUniqueInput!
  data: AppointmentUpdateWithoutClientDataInput!
}

input AppointmentUpdateWithWhereUniqueWithoutServiceInput {
  where: AppointmentWhereUniqueInput!
  data: AppointmentUpdateWithoutServiceDataInput!
}

input AppointmentUpsertWithWhereUniqueWithoutClientInput {
  where: AppointmentWhereUniqueInput!
  update: AppointmentUpdateWithoutClientDataInput!
  create: AppointmentCreateWithoutClientInput!
}

input AppointmentUpsertWithWhereUniqueWithoutServiceInput {
  where: AppointmentWhereUniqueInput!
  update: AppointmentUpdateWithoutServiceDataInput!
  create: AppointmentCreateWithoutServiceInput!
}

input AppointmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  service: DoctorWhereInput
  client: UserWhereInput
  clientName: String
  clientName_not: String
  clientName_in: [String!]
  clientName_not_in: [String!]
  clientName_lt: String
  clientName_lte: String
  clientName_gt: String
  clientName_gte: String
  clientName_contains: String
  clientName_not_contains: String
  clientName_starts_with: String
  clientName_not_starts_with: String
  clientName_ends_with: String
  clientName_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  duration: AppointmentDuration
  duration_not: AppointmentDuration
  duration_in: [AppointmentDuration!]
  duration_not_in: [AppointmentDuration!]
  local: Boolean
  local_not: Boolean
  AND: [AppointmentWhereInput!]
  OR: [AppointmentWhereInput!]
  NOT: [AppointmentWhereInput!]
}

input AppointmentWhereUniqueInput {
  id: ID
  startTime: String
  endTime: String
}

type BatchPayload {
  count: Long!
}

type ClientMessage {
  id: ID!
  sender: User!
  reciever: Doctor!
  subject: String!
  body: String!
}

type ClientMessageConnection {
  pageInfo: PageInfo!
  edges: [ClientMessageEdge]!
  aggregate: AggregateClientMessage!
}

input ClientMessageCreateInput {
  sender: UserCreateOneWithoutSentMessagesInput!
  reciever: DoctorCreateOneWithoutRecievedMessagesInput!
  subject: String!
  body: String!
}

input ClientMessageCreateManyWithoutRecieverInput {
  create: [ClientMessageCreateWithoutRecieverInput!]
  connect: [ClientMessageWhereUniqueInput!]
}

input ClientMessageCreateManyWithoutSenderInput {
  create: [ClientMessageCreateWithoutSenderInput!]
  connect: [ClientMessageWhereUniqueInput!]
}

input ClientMessageCreateWithoutRecieverInput {
  sender: UserCreateOneWithoutSentMessagesInput!
  subject: String!
  body: String!
}

input ClientMessageCreateWithoutSenderInput {
  reciever: DoctorCreateOneWithoutRecievedMessagesInput!
  subject: String!
  body: String!
}

type ClientMessageEdge {
  node: ClientMessage!
  cursor: String!
}

enum ClientMessageOrderByInput {
  id_ASC
  id_DESC
  subject_ASC
  subject_DESC
  body_ASC
  body_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClientMessagePreviousValues {
  id: ID!
  subject: String!
  body: String!
}

input ClientMessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [ClientMessageScalarWhereInput!]
  OR: [ClientMessageScalarWhereInput!]
  NOT: [ClientMessageScalarWhereInput!]
}

type ClientMessageSubscriptionPayload {
  mutation: MutationType!
  node: ClientMessage
  updatedFields: [String!]
  previousValues: ClientMessagePreviousValues
}

input ClientMessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientMessageWhereInput
  AND: [ClientMessageSubscriptionWhereInput!]
  OR: [ClientMessageSubscriptionWhereInput!]
  NOT: [ClientMessageSubscriptionWhereInput!]
}

input ClientMessageUpdateInput {
  sender: UserUpdateOneRequiredWithoutSentMessagesInput
  reciever: DoctorUpdateOneRequiredWithoutRecievedMessagesInput
  subject: String
  body: String
}

input ClientMessageUpdateManyDataInput {
  subject: String
  body: String
}

input ClientMessageUpdateManyMutationInput {
  subject: String
  body: String
}

input ClientMessageUpdateManyWithoutRecieverInput {
  create: [ClientMessageCreateWithoutRecieverInput!]
  delete: [ClientMessageWhereUniqueInput!]
  connect: [ClientMessageWhereUniqueInput!]
  set: [ClientMessageWhereUniqueInput!]
  disconnect: [ClientMessageWhereUniqueInput!]
  update: [ClientMessageUpdateWithWhereUniqueWithoutRecieverInput!]
  upsert: [ClientMessageUpsertWithWhereUniqueWithoutRecieverInput!]
  deleteMany: [ClientMessageScalarWhereInput!]
  updateMany: [ClientMessageUpdateManyWithWhereNestedInput!]
}

input ClientMessageUpdateManyWithoutSenderInput {
  create: [ClientMessageCreateWithoutSenderInput!]
  delete: [ClientMessageWhereUniqueInput!]
  connect: [ClientMessageWhereUniqueInput!]
  set: [ClientMessageWhereUniqueInput!]
  disconnect: [ClientMessageWhereUniqueInput!]
  update: [ClientMessageUpdateWithWhereUniqueWithoutSenderInput!]
  upsert: [ClientMessageUpsertWithWhereUniqueWithoutSenderInput!]
  deleteMany: [ClientMessageScalarWhereInput!]
  updateMany: [ClientMessageUpdateManyWithWhereNestedInput!]
}

input ClientMessageUpdateManyWithWhereNestedInput {
  where: ClientMessageScalarWhereInput!
  data: ClientMessageUpdateManyDataInput!
}

input ClientMessageUpdateWithoutRecieverDataInput {
  sender: UserUpdateOneRequiredWithoutSentMessagesInput
  subject: String
  body: String
}

input ClientMessageUpdateWithoutSenderDataInput {
  reciever: DoctorUpdateOneRequiredWithoutRecievedMessagesInput
  subject: String
  body: String
}

input ClientMessageUpdateWithWhereUniqueWithoutRecieverInput {
  where: ClientMessageWhereUniqueInput!
  data: ClientMessageUpdateWithoutRecieverDataInput!
}

input ClientMessageUpdateWithWhereUniqueWithoutSenderInput {
  where: ClientMessageWhereUniqueInput!
  data: ClientMessageUpdateWithoutSenderDataInput!
}

input ClientMessageUpsertWithWhereUniqueWithoutRecieverInput {
  where: ClientMessageWhereUniqueInput!
  update: ClientMessageUpdateWithoutRecieverDataInput!
  create: ClientMessageCreateWithoutRecieverInput!
}

input ClientMessageUpsertWithWhereUniqueWithoutSenderInput {
  where: ClientMessageWhereUniqueInput!
  update: ClientMessageUpdateWithoutSenderDataInput!
  create: ClientMessageCreateWithoutSenderInput!
}

input ClientMessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sender: UserWhereInput
  reciever: DoctorWhereInput
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [ClientMessageWhereInput!]
  OR: [ClientMessageWhereInput!]
  NOT: [ClientMessageWhereInput!]
}

input ClientMessageWhereUniqueInput {
  id: ID
}

type Doctor {
  id: ID!
  fullName: String!
  Bio: String
  email: String!
  password: String!
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  appointments(where: AppointmentWhereInput, orderBy: AppointmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Appointment!]
  specialty: DoctorSpecialty!
  sentMessages(where: ServiceMessageWhereInput, orderBy: ServiceMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ServiceMessage!]
  recievedMessages(where: ClientMessageWhereInput, orderBy: ClientMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClientMessage!]
}

type DoctorConnection {
  pageInfo: PageInfo!
  edges: [DoctorEdge]!
  aggregate: AggregateDoctor!
}

input DoctorCreateInput {
  fullName: String!
  Bio: String
  email: String!
  password: String!
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  appointments: AppointmentCreateManyWithoutServiceInput
  specialty: DoctorSpecialty!
  sentMessages: ServiceMessageCreateManyWithoutSenderInput
  recievedMessages: ClientMessageCreateManyWithoutRecieverInput
}

input DoctorCreateOneWithoutAppointmentsInput {
  create: DoctorCreateWithoutAppointmentsInput
  connect: DoctorWhereUniqueInput
}

input DoctorCreateOneWithoutRecievedMessagesInput {
  create: DoctorCreateWithoutRecievedMessagesInput
  connect: DoctorWhereUniqueInput
}

input DoctorCreateOneWithoutSentMessagesInput {
  create: DoctorCreateWithoutSentMessagesInput
  connect: DoctorWhereUniqueInput
}

input DoctorCreateWithoutAppointmentsInput {
  fullName: String!
  Bio: String
  email: String!
  password: String!
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  specialty: DoctorSpecialty!
  sentMessages: ServiceMessageCreateManyWithoutSenderInput
  recievedMessages: ClientMessageCreateManyWithoutRecieverInput
}

input DoctorCreateWithoutRecievedMessagesInput {
  fullName: String!
  Bio: String
  email: String!
  password: String!
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  appointments: AppointmentCreateManyWithoutServiceInput
  specialty: DoctorSpecialty!
  sentMessages: ServiceMessageCreateManyWithoutSenderInput
}

input DoctorCreateWithoutSentMessagesInput {
  fullName: String!
  Bio: String
  email: String!
  password: String!
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  appointments: AppointmentCreateManyWithoutServiceInput
  specialty: DoctorSpecialty!
  recievedMessages: ClientMessageCreateManyWithoutRecieverInput
}

type DoctorEdge {
  node: Doctor!
  cursor: String!
}

enum DoctorOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  Bio_ASC
  Bio_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  age_ASC
  age_DESC
  phone_ASC
  phone_DESC
  gender_ASC
  gender_DESC
  avatar_ASC
  avatar_DESC
  specialty_ASC
  specialty_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DoctorPreviousValues {
  id: ID!
  fullName: String!
  Bio: String
  email: String!
  password: String!
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  specialty: DoctorSpecialty!
}

enum DoctorSpecialty {
  Generaliste
  Psychiatre
  Psychologue
  Dermatologue
  Dentiste
  Gynecologue
}

type DoctorSubscriptionPayload {
  mutation: MutationType!
  node: Doctor
  updatedFields: [String!]
  previousValues: DoctorPreviousValues
}

input DoctorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DoctorWhereInput
  AND: [DoctorSubscriptionWhereInput!]
  OR: [DoctorSubscriptionWhereInput!]
  NOT: [DoctorSubscriptionWhereInput!]
}

input DoctorUpdateInput {
  fullName: String
  Bio: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  appointments: AppointmentUpdateManyWithoutServiceInput
  specialty: DoctorSpecialty
  sentMessages: ServiceMessageUpdateManyWithoutSenderInput
  recievedMessages: ClientMessageUpdateManyWithoutRecieverInput
}

input DoctorUpdateManyMutationInput {
  fullName: String
  Bio: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  specialty: DoctorSpecialty
}

input DoctorUpdateOneRequiredWithoutAppointmentsInput {
  create: DoctorCreateWithoutAppointmentsInput
  update: DoctorUpdateWithoutAppointmentsDataInput
  upsert: DoctorUpsertWithoutAppointmentsInput
  connect: DoctorWhereUniqueInput
}

input DoctorUpdateOneRequiredWithoutRecievedMessagesInput {
  create: DoctorCreateWithoutRecievedMessagesInput
  update: DoctorUpdateWithoutRecievedMessagesDataInput
  upsert: DoctorUpsertWithoutRecievedMessagesInput
  connect: DoctorWhereUniqueInput
}

input DoctorUpdateOneRequiredWithoutSentMessagesInput {
  create: DoctorCreateWithoutSentMessagesInput
  update: DoctorUpdateWithoutSentMessagesDataInput
  upsert: DoctorUpsertWithoutSentMessagesInput
  connect: DoctorWhereUniqueInput
}

input DoctorUpdateWithoutAppointmentsDataInput {
  fullName: String
  Bio: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  specialty: DoctorSpecialty
  sentMessages: ServiceMessageUpdateManyWithoutSenderInput
  recievedMessages: ClientMessageUpdateManyWithoutRecieverInput
}

input DoctorUpdateWithoutRecievedMessagesDataInput {
  fullName: String
  Bio: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  appointments: AppointmentUpdateManyWithoutServiceInput
  specialty: DoctorSpecialty
  sentMessages: ServiceMessageUpdateManyWithoutSenderInput
}

input DoctorUpdateWithoutSentMessagesDataInput {
  fullName: String
  Bio: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  appointments: AppointmentUpdateManyWithoutServiceInput
  specialty: DoctorSpecialty
  recievedMessages: ClientMessageUpdateManyWithoutRecieverInput
}

input DoctorUpsertWithoutAppointmentsInput {
  update: DoctorUpdateWithoutAppointmentsDataInput!
  create: DoctorCreateWithoutAppointmentsInput!
}

input DoctorUpsertWithoutRecievedMessagesInput {
  update: DoctorUpdateWithoutRecievedMessagesDataInput!
  create: DoctorCreateWithoutRecievedMessagesInput!
}

input DoctorUpsertWithoutSentMessagesInput {
  update: DoctorUpdateWithoutSentMessagesDataInput!
  create: DoctorCreateWithoutSentMessagesInput!
}

input DoctorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  Bio: String
  Bio_not: String
  Bio_in: [String!]
  Bio_not_in: [String!]
  Bio_lt: String
  Bio_lte: String
  Bio_gt: String
  Bio_gte: String
  Bio_contains: String
  Bio_not_contains: String
  Bio_starts_with: String
  Bio_not_starts_with: String
  Bio_ends_with: String
  Bio_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  age: Int
  age_not: Int
  age_in: [Int!]
  age_not_in: [Int!]
  age_lt: Int
  age_lte: Int
  age_gt: Int
  age_gte: Int
  phone: Int
  phone_not: Int
  phone_in: [Int!]
  phone_not_in: [Int!]
  phone_lt: Int
  phone_lte: Int
  phone_gt: Int
  phone_gte: Int
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  appointments_every: AppointmentWhereInput
  appointments_some: AppointmentWhereInput
  appointments_none: AppointmentWhereInput
  specialty: DoctorSpecialty
  specialty_not: DoctorSpecialty
  specialty_in: [DoctorSpecialty!]
  specialty_not_in: [DoctorSpecialty!]
  sentMessages_every: ServiceMessageWhereInput
  sentMessages_some: ServiceMessageWhereInput
  sentMessages_none: ServiceMessageWhereInput
  recievedMessages_every: ClientMessageWhereInput
  recievedMessages_some: ClientMessageWhereInput
  recievedMessages_none: ClientMessageWhereInput
  AND: [DoctorWhereInput!]
  OR: [DoctorWhereInput!]
  NOT: [DoctorWhereInput!]
}

input DoctorWhereUniqueInput {
  id: ID
  email: String
}

enum Gender {
  MALE
  FEMALE
}

scalar Long

type Mutation {
  createAppointment(data: AppointmentCreateInput!): Appointment!
  updateAppointment(data: AppointmentUpdateInput!, where: AppointmentWhereUniqueInput!): Appointment
  updateManyAppointments(data: AppointmentUpdateManyMutationInput!, where: AppointmentWhereInput): BatchPayload!
  upsertAppointment(where: AppointmentWhereUniqueInput!, create: AppointmentCreateInput!, update: AppointmentUpdateInput!): Appointment!
  deleteAppointment(where: AppointmentWhereUniqueInput!): Appointment
  deleteManyAppointments(where: AppointmentWhereInput): BatchPayload!
  createClientMessage(data: ClientMessageCreateInput!): ClientMessage!
  updateClientMessage(data: ClientMessageUpdateInput!, where: ClientMessageWhereUniqueInput!): ClientMessage
  updateManyClientMessages(data: ClientMessageUpdateManyMutationInput!, where: ClientMessageWhereInput): BatchPayload!
  upsertClientMessage(where: ClientMessageWhereUniqueInput!, create: ClientMessageCreateInput!, update: ClientMessageUpdateInput!): ClientMessage!
  deleteClientMessage(where: ClientMessageWhereUniqueInput!): ClientMessage
  deleteManyClientMessages(where: ClientMessageWhereInput): BatchPayload!
  createDoctor(data: DoctorCreateInput!): Doctor!
  updateDoctor(data: DoctorUpdateInput!, where: DoctorWhereUniqueInput!): Doctor
  updateManyDoctors(data: DoctorUpdateManyMutationInput!, where: DoctorWhereInput): BatchPayload!
  upsertDoctor(where: DoctorWhereUniqueInput!, create: DoctorCreateInput!, update: DoctorUpdateInput!): Doctor!
  deleteDoctor(where: DoctorWhereUniqueInput!): Doctor
  deleteManyDoctors(where: DoctorWhereInput): BatchPayload!
  createServiceMessage(data: ServiceMessageCreateInput!): ServiceMessage!
  updateServiceMessage(data: ServiceMessageUpdateInput!, where: ServiceMessageWhereUniqueInput!): ServiceMessage
  updateManyServiceMessages(data: ServiceMessageUpdateManyMutationInput!, where: ServiceMessageWhereInput): BatchPayload!
  upsertServiceMessage(where: ServiceMessageWhereUniqueInput!, create: ServiceMessageCreateInput!, update: ServiceMessageUpdateInput!): ServiceMessage!
  deleteServiceMessage(where: ServiceMessageWhereUniqueInput!): ServiceMessage
  deleteManyServiceMessages(where: ServiceMessageWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  appointment(where: AppointmentWhereUniqueInput!): Appointment
  appointments(where: AppointmentWhereInput, orderBy: AppointmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Appointment]!
  appointmentsConnection(where: AppointmentWhereInput, orderBy: AppointmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AppointmentConnection!
  clientMessage(where: ClientMessageWhereUniqueInput!): ClientMessage
  clientMessages(where: ClientMessageWhereInput, orderBy: ClientMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClientMessage]!
  clientMessagesConnection(where: ClientMessageWhereInput, orderBy: ClientMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientMessageConnection!
  doctor(where: DoctorWhereUniqueInput!): Doctor
  doctors(where: DoctorWhereInput, orderBy: DoctorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Doctor]!
  doctorsConnection(where: DoctorWhereInput, orderBy: DoctorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DoctorConnection!
  serviceMessage(where: ServiceMessageWhereUniqueInput!): ServiceMessage
  serviceMessages(where: ServiceMessageWhereInput, orderBy: ServiceMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ServiceMessage]!
  serviceMessagesConnection(where: ServiceMessageWhereInput, orderBy: ServiceMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ServiceMessageConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type ServiceMessage {
  id: ID!
  sender: Doctor!
  reciever: User!
  subject: String!
  body: String!
}

type ServiceMessageConnection {
  pageInfo: PageInfo!
  edges: [ServiceMessageEdge]!
  aggregate: AggregateServiceMessage!
}

input ServiceMessageCreateInput {
  sender: DoctorCreateOneWithoutSentMessagesInput!
  reciever: UserCreateOneWithoutRecievedMessagesInput!
  subject: String!
  body: String!
}

input ServiceMessageCreateManyWithoutRecieverInput {
  create: [ServiceMessageCreateWithoutRecieverInput!]
  connect: [ServiceMessageWhereUniqueInput!]
}

input ServiceMessageCreateManyWithoutSenderInput {
  create: [ServiceMessageCreateWithoutSenderInput!]
  connect: [ServiceMessageWhereUniqueInput!]
}

input ServiceMessageCreateWithoutRecieverInput {
  sender: DoctorCreateOneWithoutSentMessagesInput!
  subject: String!
  body: String!
}

input ServiceMessageCreateWithoutSenderInput {
  reciever: UserCreateOneWithoutRecievedMessagesInput!
  subject: String!
  body: String!
}

type ServiceMessageEdge {
  node: ServiceMessage!
  cursor: String!
}

enum ServiceMessageOrderByInput {
  id_ASC
  id_DESC
  subject_ASC
  subject_DESC
  body_ASC
  body_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ServiceMessagePreviousValues {
  id: ID!
  subject: String!
  body: String!
}

input ServiceMessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [ServiceMessageScalarWhereInput!]
  OR: [ServiceMessageScalarWhereInput!]
  NOT: [ServiceMessageScalarWhereInput!]
}

type ServiceMessageSubscriptionPayload {
  mutation: MutationType!
  node: ServiceMessage
  updatedFields: [String!]
  previousValues: ServiceMessagePreviousValues
}

input ServiceMessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ServiceMessageWhereInput
  AND: [ServiceMessageSubscriptionWhereInput!]
  OR: [ServiceMessageSubscriptionWhereInput!]
  NOT: [ServiceMessageSubscriptionWhereInput!]
}

input ServiceMessageUpdateInput {
  sender: DoctorUpdateOneRequiredWithoutSentMessagesInput
  reciever: UserUpdateOneRequiredWithoutRecievedMessagesInput
  subject: String
  body: String
}

input ServiceMessageUpdateManyDataInput {
  subject: String
  body: String
}

input ServiceMessageUpdateManyMutationInput {
  subject: String
  body: String
}

input ServiceMessageUpdateManyWithoutRecieverInput {
  create: [ServiceMessageCreateWithoutRecieverInput!]
  delete: [ServiceMessageWhereUniqueInput!]
  connect: [ServiceMessageWhereUniqueInput!]
  set: [ServiceMessageWhereUniqueInput!]
  disconnect: [ServiceMessageWhereUniqueInput!]
  update: [ServiceMessageUpdateWithWhereUniqueWithoutRecieverInput!]
  upsert: [ServiceMessageUpsertWithWhereUniqueWithoutRecieverInput!]
  deleteMany: [ServiceMessageScalarWhereInput!]
  updateMany: [ServiceMessageUpdateManyWithWhereNestedInput!]
}

input ServiceMessageUpdateManyWithoutSenderInput {
  create: [ServiceMessageCreateWithoutSenderInput!]
  delete: [ServiceMessageWhereUniqueInput!]
  connect: [ServiceMessageWhereUniqueInput!]
  set: [ServiceMessageWhereUniqueInput!]
  disconnect: [ServiceMessageWhereUniqueInput!]
  update: [ServiceMessageUpdateWithWhereUniqueWithoutSenderInput!]
  upsert: [ServiceMessageUpsertWithWhereUniqueWithoutSenderInput!]
  deleteMany: [ServiceMessageScalarWhereInput!]
  updateMany: [ServiceMessageUpdateManyWithWhereNestedInput!]
}

input ServiceMessageUpdateManyWithWhereNestedInput {
  where: ServiceMessageScalarWhereInput!
  data: ServiceMessageUpdateManyDataInput!
}

input ServiceMessageUpdateWithoutRecieverDataInput {
  sender: DoctorUpdateOneRequiredWithoutSentMessagesInput
  subject: String
  body: String
}

input ServiceMessageUpdateWithoutSenderDataInput {
  reciever: UserUpdateOneRequiredWithoutRecievedMessagesInput
  subject: String
  body: String
}

input ServiceMessageUpdateWithWhereUniqueWithoutRecieverInput {
  where: ServiceMessageWhereUniqueInput!
  data: ServiceMessageUpdateWithoutRecieverDataInput!
}

input ServiceMessageUpdateWithWhereUniqueWithoutSenderInput {
  where: ServiceMessageWhereUniqueInput!
  data: ServiceMessageUpdateWithoutSenderDataInput!
}

input ServiceMessageUpsertWithWhereUniqueWithoutRecieverInput {
  where: ServiceMessageWhereUniqueInput!
  update: ServiceMessageUpdateWithoutRecieverDataInput!
  create: ServiceMessageCreateWithoutRecieverInput!
}

input ServiceMessageUpsertWithWhereUniqueWithoutSenderInput {
  where: ServiceMessageWhereUniqueInput!
  update: ServiceMessageUpdateWithoutSenderDataInput!
  create: ServiceMessageCreateWithoutSenderInput!
}

input ServiceMessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sender: DoctorWhereInput
  reciever: UserWhereInput
  subject: String
  subject_not: String
  subject_in: [String!]
  subject_not_in: [String!]
  subject_lt: String
  subject_lte: String
  subject_gt: String
  subject_gte: String
  subject_contains: String
  subject_not_contains: String
  subject_starts_with: String
  subject_not_starts_with: String
  subject_ends_with: String
  subject_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [ServiceMessageWhereInput!]
  OR: [ServiceMessageWhereInput!]
  NOT: [ServiceMessageWhereInput!]
}

input ServiceMessageWhereUniqueInput {
  id: ID
}

type Subscription {
  appointment(where: AppointmentSubscriptionWhereInput): AppointmentSubscriptionPayload
  clientMessage(where: ClientMessageSubscriptionWhereInput): ClientMessageSubscriptionPayload
  doctor(where: DoctorSubscriptionWhereInput): DoctorSubscriptionPayload
  serviceMessage(where: ServiceMessageSubscriptionWhereInput): ServiceMessageSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  age: Int!
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean!
  Appointments(where: AppointmentWhereInput, orderBy: AppointmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Appointment!]
  sentMessages(where: ClientMessageWhereInput, orderBy: ClientMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClientMessage!]
  recievedMessages(where: ServiceMessageWhereInput, orderBy: ServiceMessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ServiceMessage!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  fullName: String!
  email: String!
  password: String!
  age: Int!
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
  Appointments: AppointmentCreateManyWithoutClientInput
  sentMessages: ClientMessageCreateManyWithoutSenderInput
  recievedMessages: ServiceMessageCreateManyWithoutRecieverInput
}

input UserCreateOneWithoutAppointmentsInput {
  create: UserCreateWithoutAppointmentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutRecievedMessagesInput {
  create: UserCreateWithoutRecievedMessagesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutSentMessagesInput {
  create: UserCreateWithoutSentMessagesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAppointmentsInput {
  fullName: String!
  email: String!
  password: String!
  age: Int!
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
  sentMessages: ClientMessageCreateManyWithoutSenderInput
  recievedMessages: ServiceMessageCreateManyWithoutRecieverInput
}

input UserCreateWithoutRecievedMessagesInput {
  fullName: String!
  email: String!
  password: String!
  age: Int!
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
  Appointments: AppointmentCreateManyWithoutClientInput
  sentMessages: ClientMessageCreateManyWithoutSenderInput
}

input UserCreateWithoutSentMessagesInput {
  fullName: String!
  email: String!
  password: String!
  age: Int!
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
  Appointments: AppointmentCreateManyWithoutClientInput
  recievedMessages: ServiceMessageCreateManyWithoutRecieverInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  age_ASC
  age_DESC
  phone_ASC
  phone_DESC
  gender_ASC
  gender_DESC
  avatar_ASC
  avatar_DESC
  confirmation_ASC
  confirmation_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  age: Int!
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  fullName: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
  Appointments: AppointmentUpdateManyWithoutClientInput
  sentMessages: ClientMessageUpdateManyWithoutSenderInput
  recievedMessages: ServiceMessageUpdateManyWithoutRecieverInput
}

input UserUpdateManyMutationInput {
  fullName: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
}

input UserUpdateOneRequiredWithoutRecievedMessagesInput {
  create: UserCreateWithoutRecievedMessagesInput
  update: UserUpdateWithoutRecievedMessagesDataInput
  upsert: UserUpsertWithoutRecievedMessagesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutSentMessagesInput {
  create: UserCreateWithoutSentMessagesInput
  update: UserUpdateWithoutSentMessagesDataInput
  upsert: UserUpsertWithoutSentMessagesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutAppointmentsInput {
  create: UserCreateWithoutAppointmentsInput
  update: UserUpdateWithoutAppointmentsDataInput
  upsert: UserUpsertWithoutAppointmentsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAppointmentsDataInput {
  fullName: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
  sentMessages: ClientMessageUpdateManyWithoutSenderInput
  recievedMessages: ServiceMessageUpdateManyWithoutRecieverInput
}

input UserUpdateWithoutRecievedMessagesDataInput {
  fullName: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
  Appointments: AppointmentUpdateManyWithoutClientInput
  sentMessages: ClientMessageUpdateManyWithoutSenderInput
}

input UserUpdateWithoutSentMessagesDataInput {
  fullName: String
  email: String
  password: String
  age: Int
  phone: Int
  gender: Gender
  avatar: String
  confirmation: Boolean
  Appointments: AppointmentUpdateManyWithoutClientInput
  recievedMessages: ServiceMessageUpdateManyWithoutRecieverInput
}

input UserUpsertWithoutAppointmentsInput {
  update: UserUpdateWithoutAppointmentsDataInput!
  create: UserCreateWithoutAppointmentsInput!
}

input UserUpsertWithoutRecievedMessagesInput {
  update: UserUpdateWithoutRecievedMessagesDataInput!
  create: UserCreateWithoutRecievedMessagesInput!
}

input UserUpsertWithoutSentMessagesInput {
  update: UserUpdateWithoutSentMessagesDataInput!
  create: UserCreateWithoutSentMessagesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  age: Int
  age_not: Int
  age_in: [Int!]
  age_not_in: [Int!]
  age_lt: Int
  age_lte: Int
  age_gt: Int
  age_gte: Int
  phone: Int
  phone_not: Int
  phone_in: [Int!]
  phone_not_in: [Int!]
  phone_lt: Int
  phone_lte: Int
  phone_gt: Int
  phone_gte: Int
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  confirmation: Boolean
  confirmation_not: Boolean
  Appointments_every: AppointmentWhereInput
  Appointments_some: AppointmentWhereInput
  Appointments_none: AppointmentWhereInput
  sentMessages_every: ClientMessageWhereInput
  sentMessages_some: ClientMessageWhereInput
  sentMessages_none: ClientMessageWhereInput
  recievedMessages_every: ServiceMessageWhereInput
  recievedMessages_some: ServiceMessageWhereInput
  recievedMessages_none: ServiceMessageWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    